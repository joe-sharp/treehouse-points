const fallbackData = {
  points: {
    total: 19791,
    Ruby: 3794,
    JavaScript: 3128,
    Python: 2688,
    CSS: 1874,
    Databases: 1441,
    HTML: 1121,
    Design: 951,
    "Development Tools": 839,
    Security: 776,
    "Computer Science": 636,
    "21st Century Skills": 441,
    "Digital Literacy": 161
  }
};

// edit username here
const username = 'joesharp';
fetch(`https://teamtreehouse.com/${username}.json`)
  .then(response => {
    if (!response.ok) throw new Error('Network response was not ok');
    return response.json();
  })
  .then(data => {
    // pull was a success
    const items = [];
    Object.entries(data).forEach(([key, val]) => {
      if (key.toLowerCase() === 'points') {
        Object.entries(val).forEach(([key2, val2]) => {
          if (val2 !== 0) {
            if (key2.toLowerCase() !== 'total') {
              items.push([key2, val2]);
            } else {
              const totalElem = document.querySelector('strong.total');
              if (totalElem) totalElem.textContent = val2;
            }
          }
        });
      }
    });
    processAndDisplayData(items);
  })
  .catch((error) => {
    console.warn('Could not load live Treehouse data. Showing fallback data instead.', error);
    const items = [];
    Object.entries(fallbackData.points).forEach(([key, val]) => {
      if (val !== 0 && key.toLowerCase() !== 'total') {
        items.push([key, val]);
      } else if (key.toLowerCase() === 'total') {
        const totalElem = document.querySelector('strong.total');
        if (totalElem) totalElem.textContent = val;
      }
    });
    processAndDisplayData(items);
  });

function processAndDisplayData(items) {
  // sort
  let sorted = [];
  if (items.length === 0) {
    sorted = items;
  } else {
    sorted = [items.shift()];
  }

  while (items.length > 0) {
    for (let i = 0; i < sorted.length; i++) {
      if (items[0][1] > sorted[i][1]) {
        sorted.splice(i, 0, items.shift());
        break;
      }
      if (i === sorted.length - 1) {
        sorted.push(items.shift());
        break;
      }
    }
  }

  // Create legend using DocumentFragment for better performance
  const fragment = document.createDocumentFragment();
  const ul = document.createElement('ul');
  for (const s of sorted) {
    const li = document.createElement('li');
    const em = document.createElement('em');
    const span = document.createElement('span');

    em.textContent = s[0];
    span.textContent = s[1];
    
    li.appendChild(em);
    li.appendChild(span);
    ul.appendChild(li);
  }
  fragment.appendChild(ul);

  // make legend
  const legendElem = document.querySelector('.legend');
  if (legendElem) legendElem.appendChild(fragment);

  // make pie
  createPie('.legend', '.pie');
}

const sliceSize = (dataNum, dataTotal) => (dataNum / dataTotal) * 360;

function addSlice(sliceSize, pieElement, offset, sliceID, color) {
  const pie = document.querySelector(pieElement);
  if (!pie) return;
  const sliceDiv = document.createElement('div');
  sliceDiv.className = `slice ${sliceID}`;
  const span = document.createElement('span');
  sliceDiv.appendChild(span);
  pie.appendChild(sliceDiv);
  const adjOffset = offset - 1;
  const sizeRotation = -179 + sliceSize;
  sliceDiv.style.transform = `rotate(${adjOffset}deg) translate3d(0,0,0)`;
  span.style.transform = `rotate(${sizeRotation}deg) translate3d(0,0,0)`;
  span.style.backgroundColor = color;
}

function iterateSlices(sliceSize, pieElement, offset, dataCount, sliceCount, color) {
  const sliceID = `s${dataCount}-${sliceCount}`;
  const maxSize = 179;
  if (sliceSize <= maxSize) {
    addSlice(sliceSize, pieElement, offset, sliceID, color);
  } else {
    addSlice(maxSize, pieElement, offset, sliceID, color);
    iterateSlices(sliceSize - maxSize, pieElement, offset + maxSize, dataCount, sliceCount + 1, color);
  }
}

function createPie(dataElement, pieElement) {
  const listNames = [];
  const listData = [];
  const dataLis = document.querySelectorAll(`${dataElement} li`);
  dataLis.forEach(li => {
    const em = li.querySelector('em');
    const span = li.querySelector('span');
    if (em && span) {
      listNames.push(em.textContent);
      listData.push(Number(span.textContent));
    }
  });

  const listTotal = listData.reduce((acc, val) => acc + val, 0);
  let offset = 0;
  const colors = ;

  // Create array of objects with name, value, and color
  const items = listNames.map((name, idx) => ({
    name,
    value: listData[idx],
    color: colors[name] || '#000000',
  }));

  // Group items by color for pie chart
  const colorGroups = {};
  items.forEach(item => {
    if (!colorGroups[item.color]) {
      colorGroups[item.color] = [];
    }
    colorGroups[item.color].push(item);
  });

  // Create flattened array grouped by color
  const groupedItems = Object.values(colorGroups).flat();

  // Draw pie slices in color groups
  groupedItems.forEach((item, i) => {
    const size = sliceSize(item.value, listTotal);
    iterateSlices(size, pieElement, offset, i, 0, item.color);
    offset += size;
  });
  removeSpinner();

  // Set legend colors in original order
  items.forEach((item, i) => {
    const li = dataLis[i];
    if (li) li.style.borderColor = item.color;
  });
}
